

                        ============================
                        Package management on Genode
                        ============================


                               Norman Feske


Abstract
########

This document explains Genode's approach and tools for package management.

; XXX section overview


Design goals and inspirations
#############################

Traditionally, the system-integration work flows of Genode were based on
the 'run' tool, which automates the building, configuration, integration,
and testing of Genode-based systems. Whereas the run tool succeeds in
overcoming the challenges that come with Genode's diversity of kernels and
supported hardware platforms, its scalability is somewhat limited to
appliance-like system scenarios: The result of the integration process is
a system image with a certain feature set. Whenever requirements change,
the system image is replaced with a new created image that takes those
requirements into account. In practice, there are two limitations of this
system-integration approach:

First, since the run tool implicitly builds all components required for a
system scenario, the system integrator has to compile all components from
source. E.g., if a system includes a component based on Qt5, one needs to
compile the entire Qt5 application framework, which impedes significant
overhead to the actual system-integration tasks of composing and configuring
components.

Second, general-purpose systems tend to become too complex and diverse to be
treated as system images. When looking as commodity OSes, each installation
differs with respect to the installed set of applications, user preferences,
used device drivers and system preferences. A system based on the run tool's
work flow would require the user customize the run script of the system for
each tweak. To stay up to date with, the user would need to re-create the
system image from time to time while manually maintaining any customizations.
In practice, this is a burden, very few end users are willing to endure.

The primary goal of Genode's package management is to overcome these
scalability limitations, in particular:

* Alleviating the need to build everything that goes into system scenarios
  from scratch,
* Facilitating modular system compositions while abstracting from technical
  details,
* On-target system update and system development,
* Assuring the user that system updates are safe to apply by providing the
  ability to easily roll back the system or parts thereof to previous versions,
* Securing the integrity of the deployed software,
* Fostering a federalistic evolution of Genode systems,
* Low friction for existing developers.

The design of Genode's package-management concept is largely influenced
by Git as well as the [https://nixos.org/nix/ - Nix] package manager. In
particular the latter opened our eyes to discover the potential that lies
beyond the package management of state-of-the art commodity systems. Even
though we considered adapting Nix for Genode and actually conducted intensive
experiments in this direction (thanks to Emery Hemingway who pushed forward
this line of work), we settled on a custom solution that leverages Genode's
holistic view on all levels of the operating system including the build system
and tooling, source structure, ABI design, framework API, system
configuration, inter-component interaction, and the components itself. Whereby
Nix is designed for being used on top of Linux, Genode's whole-systems view
led us to simplifications that eliminated the needs for Nix' powerful features
like its custom description language.


Nomenclature
############

When speaking about "package management", one has to clarify what a "package"
in the context of an operating system represents. Traditionally, a package
is the unit of delivery of a bunch of "dumb" files, usually wrapped up on
a compressed archive. A package may depend on the presence of other
packages. Thereby, a dependency graph is formed. To express how packages fit
with each other, a package is usually accompanied with meta data
(description). Depending of the package manager, package descriptions follow
certain formalisms (e.g., package-description language) and express
more-or-less complex concepts such as versioning schemes or the distinction
between hard and soft dependencies.

Genode's package management does not follow this notion of a "package".
Instead of subsuming all deliverable content under one term, we distinguish
different kinds of content in a simpler form. To avoid the clash of the
notions of the common meaning of a "package", we speak of "archives" as the
basic unit of delivery. The following subsections introduce the different
categories.
Archives are named with their version as suffix, appended via a dash. The
suffix is maintained by the author of the archive. The recommended naming
scheme is the use of the release date as version suffix, e.g.,
'report_rom-2017-05-14'.


Raw-data archives
=================

A raw-data archive contains arbitrary data that is - in contrast to executable
binaries - independent from the processor architecture. Examples are
configuration data, game assets, images, or fonts. The content of raw-data
archives is expected to be consumed by components at runtime. It is not
relevant for the build process for executable binaries. Each raw-data
archive contains merely a collection of data files. There is no meta data.


API archive
===========

An API archive has the structure of a Genode source-code repository. It may
contain all the typical content of a source-code repository such as header
files (in the _include/_ subdirectory), source codes (in the _src/_
subdirectory), library-description files (in the _lib/mk/_ subdirectory), or
ABI symbols (_lib/symbols/_ subdirectory). At the top level, a LICENSE file is
expected that clarifies the license of the contained source code. There is no
meta data contained in an API archive.

An API archive is meant to provide ingredients for building components. The
canonical example is the public programming interface of a library (header
files) and the library's binary interface in the form of an ABI symbols file.
One API archive may contain the interfaces of multiple libraries. For example,
the interfaces of libc and libm may be contained in a single "libc" API
archive because they are tightly related to each other. Conversely, an API
archive may contain a single header file only. The granularity of those
archives may vary. But the have in common that they are used at build time
only, not at runtime.


Source archive
==============

Like an API archive, a source archive has the structure of a Genode
source-tree repository and is expected to contain all the typical content of
such a source repository along with a LICENSE file. But unlike an API archive,
it contains descriptions of actual build targets in the form of Genode's usual
'target.mk' files.

In addition to the source code, a source archive contains a file
called 'used_apis', which contains a list of API-archive names with each
name on a separate line.
For example, the 'used_apis' file of the 'report_rom' source archive looks as follows:

! base-2017-05-14
! os-2017-05-13
! report_session-2017-05-13

The 'used_apis' file declared the APIs needed to incorporate into the build
process when building the source archive. Hence, they represent _build-time
dependencies_ on the specific API versions.

A source archive may be equipped with a top-level file called 'api' containing
the name of exactly one API archive. If present, it declares that the source
archive _implements_ the specified API. For example, the 'libc-2017-05-14'
source archive contains the actual source code of the libc and libm as well as
an 'api' file with the content 'libc-2017-04-13'. The latter refers to the API
implemented by this version of the libc source package.


Binary archive
==============

A binary archive contains the build result of the equally-named source archive
when built for a particular architecture. That is, all files that would appear
at the _<build-dir>/bin/_ subdirectory when building all targets present in
the source archive. There are no meta data present in a binary archive.

A binary archive is created out of the content of its corresponding source
archive and all API archives listed in the source archive's 'used_apis' file.
Note that since a binary archive depends on only one source archive, which
has no further dependencies, all binary archives can be built independently
from each other.
For example, a libc-using application needs the source code of the
application as well as the libc's API archive (the libc's header file and
ABI) but it does not need the actual libc library to be present.


Package archive
===============

A package archive contains an 'archives' file with a list of archive names
that belong together at runtime. Each listed archive appears on a separate line.
For example, the 'archives' file of the package archive for the window
manager 'wm-2017-05-15' may look as follows:

! genodelabs/raw/wm-2017-05-13
! genodelabs/src/wm-2017-05-15
! genodelabs/src/report_rom-2017-05-14
! genodelabs/src/decorator-2017-05-15
! genodelabs/src/floating_window_layouter-2017-05-15

In contrast to the list of 'used_apis' of a source archive, the content of
the 'archives' file denotes the origin of the respective archives
("genodelabs"), the archive type, followed by the versioned name of the
archive.

An 'archives' file may specify raw archives, source archives, or other
package archives (as type 'pkg'). It thereby allows the expression
of _runtime dependencies_. If a package archive lists another package
archive, it inherits the content of the listed archive. This way, a
package archive may easily customize an existing archive.

In addition to an 'archives' file, a package archive is expected to contain
a 'README' file explaining the purpose of the collection.


Depot structure
###############

Archives are stored within a directory tree called _depot/_. The depot
is structured as follows:

! <user>/pubkey
! <user>/download
! <user>/src/<name>-<version>/
! <user>/api/<name>-<version>/
! <user>/raw/<name>-<version>/
! <user>/pkg/<name>-<version>/
! <user>/bin/<arch>/<src-name>-<src-version>/
! <user>/bin/<arch>/<api-name>-<api-version>/<src-name>-<src-version>/

The <user> stands for the origin of the contained archives. For example, the
official archives provided by Genode Labs reside in a _genodelabs/_
subdirectory. Within this directory, there is a 'pubkey' file with the ASCII
version of the user's public key that is used to verify the integrity of
archives downloaded from the user. The file 'download' specifies the download
location as an URL.

By subsuming archives in a subdirectory that correspond their the origin
(user) serves two purposes. First, it provides a user-local name space for
versioning archives. E.g., there might be two versions of a
'nitpicker-2017-04-15' source archive, one by "genodelabs" and one by
"nfeske". However, since each version resides under its origin's subdirectory,
version-naming conflicts between different origins cannot happen. Second, by
allowing multiple archive origins in the depot side-by-side, package archives
may incorporate archives of different origins, which fosters the goal of a
federalistic development, where contributions of different origins can be
easily combined.

The actual archives are stored in the subdirectories named after the archive
types. Archives contained in the _bin/_ subdirectories are further subdivided
in the various architectures (like 'x86_64', or 'arm_v7'). Note that for
binaries created for source archives that implement an API (libraries), there
exists a further nesting level with API version. Therefore, multiple library
implementations (or versions) that implement the same API are located in the
same API subdirectory.


Depot management
################

* Populating the depot
  * Extract from source tree
  * Building binary archives
  * (Download)

* Publishing (signing)
  * Dependency resolution

* Downloading (verifying)
  * Dependency resolution


Automated extraction of archives from the source tree
#####################################################

* Recipes for src, api, raw, pkg

* common: hash (version name and content hash)

* api: content.mk

* src: used_apis (w/o version), api (w/o version), content.mk

* raw: content.mk

* pkg: archives (w/o version), README

  ! archives:
  ! _/pkg/wm
  ! _/raw/themed_wm
  ! _/src/themed_decorator

content.mk executed from within the archive directory

-> simple make rules


Accessing depot content from run scripts
########################################

The depot tools are not meant to replace the run tool but rather to complement
it. When both tools are combined, the run tool implicitly refers to "current"
archive versions as defined for the archive's corresponding recipes found in
Genode's source tree. This way, the regular run-tool work flow can be
maintained while attaining a productivity boost by fetching content from the
depot instead of building it.

Run scripts can use the 'import_from_depot' function to incorporate archive
content from the depot into a scenario. The function must be called after the
'create_boot_directory' function and takes any number of pkg, src, or raw
archives as arguments. An archive is specified as depot-relative path of the
form '<user>/<type>/name'. Run scripts may call 'import_from_depot'
repeatedly. Each argument can refer to a specific version of an archive or
just the version-less archive name. In the latter case, the current version
(as defined by a corresponding archive recipe in the source tree) is used.

If a 'src' archive is specified, the run tool integrates the content of
the corresponding binary archive into the scenario. The binary archives
are selected according the spec values as defined for the build directory.


